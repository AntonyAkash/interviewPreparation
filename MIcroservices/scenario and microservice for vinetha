

----------------------------------------------types of design pattern---------------
Microservices Design Patterns

1.Aggregator
2.API Gateway
3.Chained (or Chain of Responsibility)
4.Asynchronous Messaging
5.Database
6.Event Sourcing
7.Branch Pattern
8.Command Query Responsibility Segregation (CQRS)
9.Circuit Breaker
10.Decomposition Design
--------------------------------------------------ways to improve microservice security-----------------------------------


key strategies include establishing robust authentication and authorization, securing communication with mTLS protocols, prioritizing container security, implementing centralized monitoring, having an effective incident response plan, and regularly reviewing security measures

it's essential to set up authentication and authorization. Authentication checks user identity. Authorization grants access rights to a user or machine.

Authentication and authorization act like guards, controlling who can do what on a system. This is especially important in microservices because each service can have vulnerabilities.

Securing microservices with clear communication channels strengthens a network. Picture each microservice as a fort and their connections as bridges. Encrypted data travels across these bridges using transport layer security (TLS), which keeps private data safe.

Mutual TLS (MTLS) verifies the identity of both parties in a network connection and is vital to microservices security.

Implement centralized monitoring

Keep a close eye on your microservices by combining logging and monitoring. This will provide a clearer view of the system and help you locate security issues faster. Use monitoring tools like Prometheus for metrics collection and Grafana for visualization, or use comprehensive solutions like New Relic and Datadog to catch and address security concerns before they become critical. These tools aid in real-time monitoring and help analyze trends and patterns for proactive security management.

An API gateway acts as the main entrance to the system and helps manage security more effectively. This gateway makes it easier to control access and keeps data secure and private.

A gateway also manages the flow of data, helps detect and stop attacks, and ensures that data shared between services is safe, making it crucial for keeping your microservices¬†secure.


-----------------------------------------------how to improve api performance------------------
‚ö° 1. Reduce API Latency
‚úÖ a) Minimize Response Payload

Return only required fields.

@GetMapping("/users")
public List<UserDTO> getUsers() { ... } // not full entity


Use query params for selective fields:

GET /users?fields=id,name


Compress responses:

server.compression.enabled=true
server.compression.mime-types=application/json

‚öôÔ∏è 2. Use Proper Caching
‚úÖ a) Client/Server HTTP Caching

Add caching headers:

@GetMapping("/products")
public ResponseEntity<List<Product>> getProducts() {
    return ResponseEntity.ok()
        .cacheControl(CacheControl.maxAge(10, TimeUnit.MINUTES))
        .body(productService.getAll());
}

‚úÖ b) Response Caching

Use @Cacheable for frequently hit GET APIs:

@Cacheable("products")
public List<Product> getAllProducts() { ... }

üöÄ 3. Use Asynchronous & Non-blocking APIs

For parallel or independent calls inside an API:

@Async
public CompletableFuture<User> getUserDetails(Long id);


Combine multiple async calls:

CompletableFuture<User> u = userService.getUserDetails(id);
CompletableFuture<Order> o = orderService.getOrderDetails(id);
return CompletableFuture.allOf(u, o).thenApply(v -> new Response(u.get(), o.get()));


Use WebFlux + WebClient for high-concurrency APIs.

üåê 4. Reduce Network Overhead

Enable HTTP/2 (Spring Boot supports it with Tomcat/Jetty).

Use GZIP compression.

Keep payloads in JSON, avoid XML unless needed.

Group related requests ‚Äî fewer round trips (batch endpoints).

üß† 5. Smart Request Handling

ETags & Conditional Requests (send data only if modified):

return ResponseEntity.ok()
    .eTag(calculateEtag(resource))
    .body(resource);


Idempotent APIs for safe retries (PUT and DELETE should be idempotent).

Timeouts & Circuit Breakers to fail fast and avoid waiting:

@CircuitBreaker(name = "userApi", fallbackMethod = "fallbackUser")

üîÑ 6. API Gateway Level Optimizations

Use rate limiting (e.g., Spring Cloud Gateway + Resilience4j).

Enable request/response caching at gateway.

Offload authentication and logging to gateway instead of each service.

-----------------------------------------------api version controlling or backward compatability of api -------------------------
Let‚Äôs break down API Versioning and Backward Compatibility clearly, especially from a Spring Boot REST API or microservices perspective.

üß≠ 1. Why API Versioning Matters

APIs evolve ‚Äî new features, new data models, or deprecations.
But existing clients (mobile apps, frontends, or other microservices) must keep working without breaking.

So, versioning ensures:

Safe evolution of APIs.

Backward compatibility.

Controlled client migration.

‚ö° 2. Types of API Versioning
‚úÖ a) URI Versioning (most common & simplest)

Example:

GET /api/v1/users
GET /api/v2/users


Pros: Simple, clear, cache-friendly.

Cons: Duplicates code as versions increase.

Spring Boot Example:

@RestController
@RequestMapping("/api/v1/users")
public class UserControllerV1 { ... }

@RestController
@RequestMapping("/api/v2/users")
public class UserControllerV2 { ... }

‚úÖ b) Header Versioning

Clients specify version in request header:

GET /users
Header: API-Version: 2


Pros: Clean URLs; no version in path.

Cons: Harder to test in browsers; caching is trickier.

Spring Example:

@GetMapping(value = "/users", headers = "API-Version=1")
public List<UserV1> getUsersV1() { ... }

@GetMapping(value = "/users", headers = "API-Version=2")
public List<UserV2> getUsersV2() { ... }

‚úÖ c) Media Type (Content Negotiation / Accept Header)

Version included in Accept header:

GET /users
Accept: application/vnd.company.v2+json


Pros: REST-pure and standardized.

Cons: Requires more setup on both client & server.

Spring Example:

@GetMapping(value = "/users", produces = "application/vnd.company.v1+json")
public List<UserV1> getUsersV1() { ... }

@GetMapping(value = "/users", produces = "application/vnd.company.v2+json")
public List<UserV2> getUsersV2() { ... }

‚úÖ d) Query Parameter Versioning
GET /users?version=1


Pros: Easy to test; flexible for lightweight APIs.

Cons: Feels less RESTful.

Spring Example:

@GetMapping(value = "/users")
public List<User> getUsers(@RequestParam("version") int version) { ... }

-----------------------------------------------how to improve SQL performance------------------

BY INDEXING

-----------------------------------------------data base clusters------------------------------
A database cluster is a group of database servers (nodes) that work together to improve availability, scalability, and fault tolerance.

Instead of one central database, you have multiple connected databases that:

Share data (replicated)

Distribute load (partitioned or sharded)

Automatically recover from failures
------------------------------------------------------------------------------------------------------------------------
JAVA POINTERS VS C POINTERS
---------------------------------------------------------
REAL SCENARIO WHERE YOU HAVE USED PROTYPE DESIGN PATTERN

It lets you clone existing objects instead of creating new ones from scratch.

Used when object creation is expensive or complex, but a copy (with some changes) can be made quickly.

--------------------------------------------------------------------------------------------------------------
multi threading in spring boot application

1. What is Multithreading in Spring Boot?

Multithreading allows your Spring Boot application to execute multiple tasks concurrently, improving throughput and responsiveness ‚Äî especially in I/O-heavy or parallel processing scenarios.

Spring Boot provides built-in mechanisms to handle multithreading safely and efficiently using the Spring Task Execution Framework and @Async support.

‚öôÔ∏è 2. Common Use Cases
Use Case	Description
üì© Sending multiple emails or notifications in parallel	Fire async tasks per recipient
üöó Processing multiple ride bookings	Each booking request runs in its own thread
üìà Batch jobs / data import	Each file or record processed concurrently
üåê Calling multiple external APIs	Parallel API calls using async or CompletableFuture
üß† Heavy computations	Offload long-running tasks from main thread
üöÄ 3. Enabling Multithreading in Spring Boot
Step 1: Enable Async Support

Add @EnableAsync in your main application class:

@SpringBootApplication
@EnableAsync
public class DemoApplication { }

Step 2: Define Async Methods

Use @Async on methods that should run in a separate thread:

@Service
public class NotificationService {

    @Async
    public void sendEmail(String email) {
        System.out.println("Sending email to: " + email + " - " + Thread.currentThread().getName());
        // simulate delay
        try { Thread.sleep(2000); } catch (InterruptedException e) { }
        System.out.println("Email sent to: " + email);
    }
}
-------------------------------------------------------------------------------------------------------------

CREATE DATE IN THE GIVEN FORMAT USING JAVA INBUILT METHODS (dd/MM/yyyy)

DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
LocalDate date = LocalDate.parse(dateStr, formatter);

-------------------------------------------------------------------------------------------

GRAPHQL WHEN TO USE IT
-------------------------------------How to Handle Memory leaks----------------------------

memory leaks in a Java/Spring Boot application can be handled by

 @PreDestroy
        public void cleanup() {
            listeners.clear(); // prevent memory leak at shutdown
        }

//try with resource
public void processDatabase() {
        // Use try-with-resources to avoid leaks
        try (var conn = Database.getConnection()) {
            // process
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

//dereferencing
public static void clearGlobalCache() {
        globalCache.clear(); // free memory
        globalCache = null;  // remove static reference
    }
-------------------------------------

1. What is Salting?

Salting is the process of adding a random string (called a salt) to a password before hashing it.

----------Purpose:

Prevent attackers from using precomputed hash tables (rainbow tables) to crack passwords.

Make identical passwords hash differently for each user.

collitions wont happen if we use salting

---------how it works

2. How it Works (Step by Step)

User creates a password:

Password: "MySecret123"


Generate a random salt:

Salt: "x8!G9pL2"


Combine password + salt:

"MySecret123x8!G9pL2"


Hash the combined string (e.g., using SHA-256 or bcrypt):

Hash: "7d3f1c4a..."


--------------------------------------------



1. Map vs FlatMap ‚Äî Concept  //Vine I will explain this

Operator   Input ‚Üí Output	Description
map	   T ‚Üí R	        Transforms each element of a stream into exactly one element in the resulting stream.
flatMap	  T ‚Üí Stream<R>  	Transforms each element into a stream of elements, then flattens all streams into a single stream.

Example 1: Map
import java.util.*;
import java.util.stream.*;

public class MapExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Antony", "John");

        // map: convert to upper case
        List<String> upper = names.stream()
                                  .map(String::toUpperCase)
                                  .collect(Collectors.toList());

        System.out.println(upper);
    }
}


Output:

[ANTONY, JOHN]


‚úÖ Each element maps to exactly one element.

Example 2: FlatMap

Suppose each name has multiple characters and we want a stream of characters:

import java.util.*;
import java.util.stream.*;

public class FlatMapExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Antony", "John");

        // flatMap: split each name into chars, then flatten
        List<String> chars = names.stream()
            .flatMap(name -> Arrays.stream(name.split("")))
            .collect(Collectors.toList());

        System.out.println(chars);
    }
}


Output:

[A, n, t, o, n, y, J, o, h, n]


‚úÖ flatMap flattened multiple streams (from name.split("")) into one single stream.

Example 3: Map Produces Stream ‚Äî Without FlatMap
List<Stream<String>> listOfStreams = names.stream()
    .map(name -> Arrays.stream(name.split("")))
    .collect(Collectors.toList());

System.out.println(listOfStreams);


Output:

[Ljava.util.stream.ReferencePipeline$Head@1a2b3c, ...]


Without flatMap, you get Stream of Streams, not a flat stream.

That‚Äôs why flatMap is required to flatten nested streams.

 	

